: 2DROP   drop drop ;
: \   10 parse 2DROP ; immediate         \ Now we have comments

: '
   \ Avoid using IF, which is not defined yet
   parse-word findword dup 0= ?dup 2DROP ;

: [COMPILE]   ' , ; immediate

: CHAR   parse-word drop c@ ;

: [CHAR]   CHAR [COMPILE] literal ; immediate

: (   [CHAR] ) parse 2DROP ; immediate

( Now we have round bracket comments )

\ Using the definition in [FORTH1994] A.6.1.2033
   : compile   r> dup @ , cell+ >r ;

: [']   ' [COMPILE] literal ; immediate

: RECURSE
   last name>
   ,
; immediate

: 2DUP  ( x x' -- x x' x x' )  over over ;
\ CORE-EXT
: TUCK  ( a b -- b a b )  swap over ;
\ CORE-EXT
: .(  [CHAR] ) parse type ; immediate
: S>D  ( n -- d )  dup 0< ;

\ CORE-EXT
: 2R>   ( R: x1 x2 -- ) ( -- x1 x2 )
   r> r> r>     ( ret x2 x1 )
   rot >r       ( x2 x1 )
   swap         ( x1 x2 )
;

\ DOUBLE-EXT
: 2ROT  ( p q r s t u -- r s t u p q )  2>r 2swap 2R> 2swap ;

: 2*  ( x -- x' )  2 * ;

: /MOD  ( n1 n2 -- rem quot )  >r S>D r> sm/rem ;
: */MOD  ( n1 n2 n3 -- rem quot )  >r m* r> sm/rem ;
: */  ( n1 n2 n3 -- quot )  */MOD nip ;
: /  ( n1 n2 -- n3 )  /MOD nip ;

\ DOUBLE
: M*/  ( d1 n1 +n2 -- d2 )
   >r                   ( d1 n1 )  ( r: n2 )
   \ sign has correct sign, garbage mantissa
   2DUP xor             ( d1 n1 sign )
   r> swap >r           ( d1 n1 n2 )  ( r: sign )
   2swap                ( n1 n2 d1 )
   dabs                 ( n1 n2 ud1 )
   2swap                ( ud1 n1 n2 )
   swap abs swap        ( ud1 u1 n2 )
   um*/mod drop         ( ud )
   r> d+-               ( d )  ( r: )
;

\ CORE-EXT
: U>  ( u1 u2 -- flag )  swap u< ;

: DEPTH  ( -- +n )
   stack -  1 cells / ;

: VARIABLE    create 1 cells allot ;
\ DOUBLE
: 2VARIABLE   create 2 cells allot ;

: MOD  ( n1 n2 -- n3 )
   \ Implementation as per [std1994]
   >r S>D r> sm/rem drop
;

: 2!  ( x1 x2 addr -- )  TUCK !   cell+ ! ;

: 2@  ( addr -- x1 x2 )
   dup cell+ @   swap @ ;

\ DOUBLE
: D0=  ( xd -- flag )  or 0= ;

: COUNT  ( addr -- addr' ch )  dup 1+ swap c@ ;

\ STRING
: /STRING  ( addr u n -- addr' u' )
   TUCK -               ( addr n u' )
   >r + r>              ( addr' u' )
;

\ ## Control Flow

: BEGIN  ( -- token / at compile time )
   here
; immediate

: UNTIL  ( token -- / at compile time )
   compile 0branch
   here         ( token here )
   -            ( byte-offset )
   ,
; immediate

: WHILE  ( token -- token w-token )
   compile 0branch
   here         ( token w-token )
   true ,
; immediate

: REPEAT  ( b-token w-token -- )
   swap         ( w-token b-token )
   compile branch
   here -       ( w-token offset )
   ,            ( w-token )
   here         ( w-token here )
   over -       ( w-token offset )
   swap !
; immediate

: IF  ( -- token    / at compile time )
   compile 0branch
   here         ( token )
   \ compile dummy offset
   true ,
; immediate

\ std1983
: ELSE  ( token -- newtoken      / at compile time )
   compile branch
   here         ( token newtoken )
   ( compile dummy offset )
   true ,
   swap         ( newtoken token )
   here over -  ( newtoken token offset )
   swap         ( newtoken offset token )
   !            ( newtoken )
; immediate

\ std1983
: THEN
   here over - swap ! ; immediate
   
create do-stack  3 cells allot
VARIABLE do-sp  0 do-sp !
   : do-addr   do-stack  do-sp @ cells  + ;

   : >do   do-addr !  1 do-sp +! ;
   : do>   -1 do-sp +!  do-addr @ ;

: DO  ( limit base -- )
      ( C: -- do-token )
      ( do-stack: -- leave-token )
   compile 2>r
   0 >do  here  ( do-token )
; immediate

\ Push the current-leave token (on the do-stack)
\ onto the leave linked-list at HERE.
\ Replace current-leave token with HERE.
\ Factor of LEAVE and ?DO .
: push-leave  ( -- )
   here do>     ( new-token leave-token )
   , >do
;

: ?DO  ( limit base -- )
       ( C: -- do-token )
       ( do-stack: -- leave-token )
   \ Use DO to setup a DO LOOP,
   \ but adjust the do-token so that the LOOP returns
   \ to a point after the equalty test implied by ?DO .
   compile 2DUP
   [COMPILE] DO
   compile <>
   compile 0branch
   push-leave
   drop here
; immediate

\ Implements the test part of a DO LOOP,
\ leaving a flag on the stack.
: looptest  ( -- flag    / R: limit index -- limit index' )
   r>           ( ret )
   2r@          ( ret limit index )
   1+           ( ret limit index' )
   r> drop      ( r: limit )
   dup >r       ( r: limit index' )
   =            ( ret flag )
   swap >r      ( flag )
;

\ Add inc to index and convert inc to flag;
\ flag is true iff index crosses boundary between
\ limit-1 and limit.
: +test  ( inc limit index -- flag index' )
  swap >r       ( inc index )  ( r: limit )
  2DUP +        ( inc index index' )
  dup r@ -      ( inc index index' o' )
  rot r> -      ( inc index' o' o )
  over xor      ( inc index' o' x )
  rot 2swap     ( x index' inc o' )
  xor invert    ( x index' q )
  rot and       ( index' sflag )
  0< swap       ( flag index' )
;

: +looptest  ( inc -- flag ) ( r: limit index -- limit index' )
   r> swap      ( ret inc )
   2r@          ( ret inc limit index )
   +test        ( ret flag index' )
   r> drop      ( r: limit )
   >r           ( ret flag ) ( r: limit index' )
   swap >r      ( flag )
;

: LEAVE
   compile branch
   push-leave
; immediate

\ Fix the leave token.
\ Fetch the previous leave token in the linked-list,
\ and store offset to HERE at that address.
: fix-leave  ( leave-token -- leave-token' )
   dup @ swap   ( leave-token' leave-token )
   here over    ( leave-token' leave-token here leave-token )
   - swap !     ( leave-token' )
;

: loopy
   compile 0branch
   here         ( do-token here )
   -            ( byte-offset )
   ,
   \ fix the linked-list of leave-tokens up
   do>          ( leave-token )
   BEGIN
      ?dup WHILE
      fix-leave         ( leave-token' )
   REPEAT
   compile 2R> compile 2DROP
;

: LOOP  ( R: limit base -- limit base+1 | )
        ( C: do-token -- )
   compile looptest
   loopy
; immediate

: +LOOP  ( inc -- )
         ( R: limit base -- limit base' | )
         ( C: do-token -- )
   compile +looptest
   loopy
; immediate

\ std1983
: I  ( -- index )
   2r@ drop
;

\ std1994
: J  ( -- index )  ( R: lj bj li bi ret )
   2R>  2r@ drop  rot rot 2>r
;

\ ##

: MAX   2DUP < IF swap THEN drop ;

\ Fixes the CFA of the last defined word
\ to point to address following call to *fix-cfa
\ in the calling word;
\ and terminate excution of calling word.
   : *fix-cfa   r> last name> ! ;

: DOES>   compile *fix-cfa codedoes     ( addr n )
   here over allot                      ( from n to )
   swap cmove ; immediate

: CONSTANT  ( x -- / -- x )
   VARIABLE last name> >body ! DOES> @ ;

\ CORE-EXT
: VALUE   CONSTANT ;
\ CORE-EXT
: TO  ( x -- )
   ' >body
   state @ IF
      [COMPILE] literal
      compile !
   ELSE
      !
   THEN
; immediate

: ALIGN  ( -- )
   here aligned  here  - allot
;

: C,  ( char -- )
   here  1 allot  !  ;

\ Map Anonymous
\ Request freshly allocated memory.
: map-anon  ( sz -- addr ior )
   0 swap               ( 0 sz )
   3 34                 ( 0 sz prot flags )
   -1 0                 ( 0 sz prot flags fd offset )
   9 syscall6           ( res )
   -4096 over u<        ( res flag )
   over and             ( addr ior )
;

\ ## Number Printing

300 CONSTANT pic-size
pic-size map-anon drop pic-size +
VALUE picend
VARIABLE pic

\ double to double division
\ used in printing numbers
   : uml/mod  ( ud u -- u-rem ud-quot )
      >r r@
      0 swap um/mod     ( L Mrem Mquot )
      r> swap >r        ( L Mrem u )
      um/mod            ( Lrem Lquot )
      r>                ( Lrem ud-quot )
   ;

: HOLD  ( ch -- )
   pic @        ( ch addr )
   1-           ( ch addr' )
   TUCK         ( addr' ch addr' )
   c!           ( addr' )
   pic !
;

: <#  ( -- )
   picend
   pic !
;

: #  ( ud -- ud' )
   base @
   uml/mod      ( r ud )
   rot          ( ud r )
   digit HOLD   ( ud )
;

: #S  ( ud -- 0. )
   BEGIN
      #
      2DUP      ( ud ud )
      D0=       ( ud flag )
   UNTIL
;

: SIGN  ( n -- )
   0< IF
      [CHAR] -
      HOLD
   THEN
;

: #>  ( ud -- addr u )
   2DROP
   pic @
   picend       ( addr end )
   over -       ( addr u )
;

: U.  ( u -- )
   0
   <# bl HOLD #S #>
   type
;

\ Using <#, type out double with sign of n.
   : .sign  ( n du -- )
      <#
         bl HOLD
         #S
         rot SIGN
      #>
      type
   ;

: .  ( n -- )
   dup abs 0    ( n du )        \ du same magnitude as n
   .sign ;

\ DOUBLE
: D.  ( d -- )
   TUCK dabs    ( n du )        \ n same sign as d
   .sign ;

: DECIMAL  ( -- )  10 base ! ;
\ CORE-EXT
: HEX  ( -- )  16 base ! ;

\ TOOLS
: .S  ( -- )
   stack
   ?DO
      I @ .
   1 cells  +LOOP
;

\ ## String

: ."  ( copmile: "ccc<quote>" -- )
   [COMPILE] s" compile type
; immediate

\ 3-way comparison
\ result is -1 when u1 < u2
\           +1 when u2 < u1
\            0 when u1 = u2
   : cmp  ( u1 u2 -- -1|0|1 )
      2DUP u<   ( u1 u2 flag< )
      swap rot  ( flag< u2 u1 )
      u<        ( flag< flag> )
      -
   ;

\ STRINg
: COMPARE  ( c-addr1 u1 c-addr2 u2 -- n )
   rot 2DUP 2>r
   min          ( c-addr1 c-addr2 n )
   false
   BEGIN
      drop
      dup 0= IF
        \ identical up to common part
        drop 2DROP
        r> r> cmp
        exit
      THEN
      ( c-addr1 c-addr2 n )
      1-
      rot COUNT >r      ( c-addr2 n c-addr1' )  ( r: ch1 )
      rot COUNT >r      ( n c-addr1' c-addr2' )  ( r: ch1 ch2 )
      rot 2R>           ( c-addr1' c-addr2' n ch1 ch2 )
      cmp               ( c-addr1' c-addr2' n -1|0|1 )
      dup
  UNTIL
  2R> 2DROP
  nip nip nip
;

\ print name of word given its LFA
: .lfa  ( lfa -- lfa 0 )
        ( lfa -- 1 )
   dup 0= IF
      drop
      1
      exit
   THEN
   dup                  ( lfa lfa )
   cell+                ( lfa nfa )
   dup @                ( lfa nfa u-bits )
   4294967295 and       ( lfa nfa u )
   swap cell+ swap      ( lfa c-addr u )
   here over [CHAR] ?   ( lfa c-addr u here u ? )
   fill                 ( lfa c-addr u )
   dup >r               ( lfa c-addr u )  ( r: u )
   8 min                ( lfa c-addr 8|u )
   here swap            ( lfa c-addr here 8|u )
   cmove
   here r>
   type cr
   false
;

: WORDS
   ['] .lfa thewl exec-wordlist
;

\ ##

\ Convert from C string, by pushing its length.
   : c>  ( addr -- addr u )
      -1           ( addr i )
      BEGIN
         1+        ( addr i )
         2DUP +    ( addr i p )
         c@        ( addr i ch )
         0=        ( addr i flag )
      UNTIL
   ;

\ ARGC and ARG modelled after gforth implementation.
\ The initial RSP register is the address of ARGC
\ (in the Linux ABI).
rsp CONSTANT argc
: arg  ( i -- i-addr i-len )
   1+ cells
   \ Following ARGC are the pointers to C strings.
   argc
   + @          ( addr )
   dup IF
      c>        ( addr u )
   ELSE
      0         ( 0 0 )
   THEN
;
: arg-pop  ( -- )
   argc @ 2 < IF  exit  THEN
   argc 2 cells +       ( addr-from )
   argc cell+           ( addr-from addr-to )
   -1 argc +!
   argc @ cells         ( addr-from addr-to u )
   cmove
;

\ see note/fstat.md
create fstatbuf 144 allot ALIGN

\ Modelled after ANSI `file-status`.
: file*status  ( n -- addr ior )
   \ Leaves result in `fstatbuf` which is left on stack.
   fstatbuf TUCK 0 5 syscall3 ;

\ std1994 file
: file-size  ( fileid -- ud ior )
   file*status
   ?dup IF
      0 swap                    ( x 0 ior )
   ELSE
      48 + @  0                 ( ud )
      0                         ( ud 0 )
   THEN
;

\ File Map for Reading
\ Map fildes fd into memory for reading.
\ Address and length of mapping are left on stack.
: fmapr ( fd -- addr u )
   dup file-size                        ( fd ud ior )
   abort" File cannot be mapped"        ( fd ud )
   d>s                                  ( fd u )
   dup 1 < IF
      drop drop
      0 0
   ELSE
      ( n sz )
      TUCK                              ( sz n sz )
      0 rot rot swap                    ( sz 0 sz n )
      \ For #defines, see /usr/include/asm-generic/mman-common.h
      \ PROT_READ 1
      \ PROT_WRITE 2
      \ MAP_PRIVATE 2
      \ MAP_ANONYMOUS 32
      1 2 rot                           ( sz 0 sz 1 2 n )
      0                                 ( sz 0 sz 1 2 n 0 )
      9 syscall6                        ( sz addr )
      swap
   THEN
;

4096 map-anon drop
CONSTANT openbuf        ( buffer for open pathname )

\ FILE
: R/O
   \ Modelled after the `flags` argument to open()
   \ See /usr/include/asm-generic/fcntl.h defines O_RDONLY
   0 ;

\ FILE
: OPEN-FILE  ( c-addr u fam -- fileid ior )
   >r >r                ( c-addr )      ( r: fam u )
   openbuf r@           ( c-addr path u )
   cmove                ( )
   0 r>                 ( 0 u )         ( r: fam )
   openbuf 1+ +         ( 0 p )
   !
   openbuf              ( openbuf )
   r> 0                 ( openbuf fam 0 )
   \ For syscall numbers, see
   \ http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
   2 syscall3           ( fileid )
   dup 0 min            ( fileid 0 | ior ior )
;

\ Open file for reading.
: openr  ( c-addr u -- fileid ior )
   R/O OPEN-FILE ;

\ ##

\ Fetch byte C from addr,
\ then compute C M AND X XOR
\ and store at addr.
: c!xa  ( X M addr -- )
   dup >r c@ and xor r> c! ;

VARIABLE chbuf

\ Read single byte.
: fgetc ( fd -- c/-9999999/-ve )
   chbuf 1 sysread
   dup 0< IF
   ELSE
      0= IF -9999999
      ELSE
         chbuf c@
      THEN
   THEN
;

\ Read single byte from stdin
: getc ( -- c )
       ( -- -9999999    / on End of File )
       ( -- -ve         / on os error )
   0 fgetc ;

\ Fetch and print 8 hex digits.
: @.8  ( addr -- )
   @ 4294967295 ( 2**32 - 1 ) and       ( w )
   base @ >r
   16 base !
   0                    ( ud )
   <# bl HOLD
      # # # # # # # #
   #>
   type
   r> base !
;



\ Get TTY settings, from TCGETS ioctl, and dump to stdout.
: tcgets.  ( fd -- res )
   here dup tcgets       ( here res )
   over @.8
   over 4 + @.8
   over 8 + @.8
   over 12 + @.8
   cr
   over 16 +
   20 dump              ( res )
   nip
;

create tty.buffer 36 allot ALIGN

\ Store TTY settings.
: tty.store ( fd -- )
   tty.buffer tcgets drop
;

\ Put TTY in keypress mode.
: tty.keypress ( fd -- )
   \ Fetch and modify TTY settings...
   dup here tcgets drop                 ( fd )
   \ Clear ICANON and ECHO bits.
   0  10 invert  here 12 +  c!xa        ( fd )
   here tcsets drop
;

\ Restore TTY settings.
: tty.restore  ( fd -- )
   tty.buffer tcsets drop
;

create tty.szbuf 8 allot

: tiocgwinsz  ( fd p -- res )
   \ 0x5413, TIOCGWINSZ according to /usr/include/asm-generic/ioctls.h
   21523                ( fd p 0x5413 )
   swap                 ( fd 0x5413 p )
   ( ioctl )
   16 syscall3          ( res )
;

VARIABLE tty.vbuf
-1 tty.vbuf !

\ Number of columns in TTY.
: tty.cols ( -- cols )
   0 tty.szbuf
   tiocgwinsz
   0= IF
      tty.szbuf 2+      ( a+2 )
      dup 1+            ( a+2 a+3 )
      c@ swap c@        ( b1 b0 )
      swap              ( b0 b1 )
      256 * +           ( cols )
      tty.vbuf !
   THEN
   tty.vbuf @
;

\ Put the TTY into keypress mode to get a single keypress.
: getch
   0 tty.store
   0 tty.keypress
   getc
   0 tty.restore
;

\ ## Key Input

\ type on stderr.
: etype  ( addr u -- )  2 ftype ;
\ emit on stderr.
: eemit  ( ch -- )  2 femit ;

\ size
: ki.z  96 ;
\ address
create ki.a ki.z allot
\ point
VARIABLE ki.>
\ validity
VARIABLE ki.n
VARIABLE ki.>save
\ small buffer for key input
VARIABLE ki.k
\ small buffer used for findword
VARIABLE ki.fixk

\ Reset key variables to create a fresh buffer
: ki.fresh
   0 ki.> !   0 ki.n !   0 ki.>save ! ;
ki.fresh

: ki.input  ( -- addr u )  ki.a ki.n @ ;

\ ## Historic Lines

\ Memory block for all strings in history.
VARIABLE hl.block
1000000000 map-anon drop hl.block !
\ history-pointer
VARIABLE hl.p
hl.block @ hl.p !

: hl.n   999 ;
create hl.array hl.n 2* cells allot

VARIABLE hl.next   0 hl.next !
VARIABLE hl.cursor   0 hl.cursor !

\ Index of earliest history element.
: hl.base  ( -- base )
   hl.n hl.next @ MAX
   hl.n -
;

: hl.curprev  ( -- flag )
   hl.cursor @  hl.base  >  IF
      -1 hl.cursor +!
      true
   ELSE
      0
   THEN
;

: hl.curnext  ( -- flag )
   hl.cursor @  hl.next @ 1-    ( c end )
   < IF
      1 hl.cursor +!
      true
   ELSE
      0
   THEN
;

\ Return address of uth double-world entry in hl.array.
: hl.a&  ( u -- addr )
   2* cells     ( byte-offset )
   hl.array     ( byte-offset hl.array )
   +            ( array-address )
;

\ Store addr u into the ith double-world entry in hl.array.
: hl.a!  ( u addr i -- )
   hl.a&        ( u addr array-addr )
   2!           ( )
;

\ Replace i with the address of the double word
\ for history element i;
\ 0 if invalid index.
: hl&  ( i -- addr )
   dup                  ( i i )
   hl.base              ( i i base )
   hl.next @            ( i i base limit )
   within  IF
      hl.n MOD          ( array-index )
      hl.a&             ( addr )
   ELSE
      drop
      0
   THEN
;

\ Fetch string from history; 0 0 if invalid index.
: hl@  ( i -- addr u )
   hl&                  ( addr )
   dup IF
      2@                ( u a )
      swap              ( a u )
   ELSE
      drop
      0 0
   THEN
;

\ Save the string into most recent element of history;
\ modifying it.
: hl.save  ( from u -- )
   hl.next @ 1-         ( from u i )
   hl&                  ( from u h-addr )
   dup 0= IF
      abort" hl.save problem"
   THEN
   \ :todo: check lengths here
   2DUP                 ( from u h-addr u h-addr )
   cell+ !              ( from u h-addr )
   @                    ( from u to )
   \ calculate a new value for hl.p
   2DUP                 ( from u to u to )
   +                    ( from u to new-p )
   hl.p !               ( from u to )
   swap cmove
;

\ Create a new history entry.
: hl.new  ( -- )
   0 hl.p @             ( 0 p )
   hl.next @            ( 0 p i )
   \ increment hl.next
   1 hl.next +!         ( 0 p i )
   \ set cursor
   dup hl.cursor !      ( 0 p i )
   hl&                  ( 0 p addr )
   2!
;

: hl.
   hl.base              ( i )
   BEGIN
      dup hl.next @     ( i i n )
      <                 ( i flag )
   WHILE
      dup .
      dup hl@           ( i addr u )
      type cr           ( i )
      1+                ( i+1 )
   REPEAT
   drop
;

\ hl.cursor     - which history element we are currently showing.
\ hl.next       - number of next history element to be created.
\ hl.next only ever increments.
\ The counterpart, hl.earliest, the earliest history element,
\ is not explicitly stored. It is computed by hl.base.

\ ^P and ^N move the history cursor up and down,
\ and as long as there is a history element in memory,
\ it is copied to the ki buffer.

\ History is a copy on write affair.

\ Modifying the ki buffer marks it as modified,
\ ^J saves the ki buffer to history, and marks it as frozen.
\ ^N, or ^P saves the ki buffer to history only if
\ the ki buffer is modified.

\ The most recent history element has associated with it,
\ a "frozen" flag, which is unset until enter is pressed.
\ It is used to control saving.
\ When the ki buffer is saved to history,
\ if the most recent history element is frozen,
\ a new history element is created;
\ otherwise, the most recent history element is used, then
\ marked as frozen.

\ The history list is only ever appended to.
\ Only the oldest history element can be removed,
\ and it is removed to make room for new ones.

\ The following behaviours are observed:
\ ^P and ^N scroll through history.
\ Executing a line creates a new history element.
\ Modifying a line creates a new history element,
\ but one which can be subsequently re-edited without creating
\ further new history elements.
\ ^P ... edits ... ^P ... edits ... will lose the first set of edits.


\ ## Key Input Commands

\ Insert the text into the buffer at the current point,
\ and advance the point past the inserted text.
: ki.insert  ( addr u -- 1 )
   dup ki.n @ +  ki.z  >  IF
      \ buffer full
      s" #%#" etype
      0
   ELSE
      ( addr u )
      \ copy text to right of point up to make room
      ki.a ki.> @ +     ( addr u from )
      over              ( addr u from u )
      ki.> @ + ki.a +   ( addr u from to )
      ki.n @ ki.> @ -   ( addr u from to n )
      cmove>            ( addr u )
      \ increment length
      dup ki.n +!       ( addr u )
      \ copy new input at point
      ki.a ki.> @ +     ( addr u > )
      over              ( addr u > u )
      \ bump ki.>
      ki.> +!           ( addr u > )
      swap cmove        ( )
      1
   THEN
;

\ fix-up the single character in ki.k
\ Convert Control Chars to ^J form,
\ and prefix everything with k:
: ki.fix
   s" k:" ki.fixk swap cmove
   ki.k c@  32  <  IF
      [CHAR] ^ ki.fixk 2 + c!
      ki.k c@
      64 or ki.fixk 3 + c!
      ki.fixk 4
   ELSE
      ki.k c@ ki.fixk 2 + c!
      ki.fixk 3
   THEN
;

: erase-backward-char
   ki.> @  IF
      \ copy down characters
      ki.a ki.> @ +     ( from )
      dup 1-            ( from to )
      ki.n @ ki.> @ -   ( from to n )
      cmove
      \ shrink buffer
      -1 ki.> +!
      -1 ki.n +!
   THEN
;

\ Create a binding for the current stty erase key
0 tty.store
tty.buffer 19 + c@
ki.k c!
ki.fix *create *stdexe here body> ! ] erase-backward-char 1 ; ( )

: end-of-line
   ki.n @ ki.> ! ;

\ Makes LF exit the KI loop
: k:^J
   end-of-line
   ki.input hl.save
   s"  " ki.insert drop
   0
;

\ beginning-of-line
: k:^A   0 ki.> !   1 ;

\ backward-char
: k:^B   ki.> @ 1-  0  MAX  ki.> !   1 ;

\ erase-forward-char
: k:^D
   \ if entire line is empty, terminate
   ki.n @ 0=  ki.> @ 0=  and  IF
      0  exit
   THEN
   \ Test if there are any characters ahead of point to erase.
   ki.n @  ki.> @  -  IF
      \ copy down characters
      ki.a ki.> @ +             ( to )
      dup 1+ swap               ( from to )
      ki.n @ ki.> @ - 1-        ( from to n )
      cmove
      \ shrink buffer
      -1 ki.n +!
   THEN
   1
;

\ end-of-line
: k:^E
   end-of-line   1
;

\ forward-char
: k:^F   ki.> @ 1+  ki.n @  min  ki.> !   1 ;

\ kill-to-end
: k:^K   ki.> @ ki.n !   1 ;

\ Move the current historic line into key input.
: hl.move
   hl.cursor @ hl@              ( from u )
   TUCK ki.a swap               ( u from to u )
   cmove                        ( u )
   ki.n !  0 ki.> !
;

\ next
: k:^N
   hl.curnext IF
      hl.move
   THEN
   1
;

\ previous
: k:^P
   hl.curprev IF
      hl.move
   THEN
   1
;

\ Fix cursor position if it is at end of row
: ki.curfix
   ki.n @ S>D  tty.cols  um/mod ( col row )
   0>  swap 0=  and  IF
      10 eemit
   THEN
;

\ Like #s, but always in decimal.
: #d
   base @ >r  10 base !
   #S
   r> base !
;

\ Emit ANSI codes to move VT cursor,
\ from location `from` to location `to`.
\ `from` and `to` are byte positions in the ki.a input string.
: ki.motion  ( from to -- )
   tty.cols >r
   S>D r@ um/mod                ( from to-col to-row )
   rot                          ( to-col to-row from )
   S>D r> um/mod                ( to-col to-row from-col from-row )
   rot                          ( to-col from-col from-row to-row )
   \ vertical motion
   2DUP > IF
      \ upward motion
      - S>D                     ( t-col f-col dn )
      <# [CHAR] A HOLD #d [CHAR] [ HOLD 27 HOLD #>
      etype                     ( t-col f-col )
   ELSE
      2DUP < IF
         \ downward motion
         - negate S>D           ( t-col f-col dn )
         <# [CHAR] B HOLD #d [CHAR] [ HOLD 27 HOLD #>
         etype                  ( t-col f-col )
      ELSE
         2DROP
      THEN
   THEN
   drop                         ( t-col )
   1+ S>D <# [CHAR] G HOLD #d [CHAR] [ HOLD 27 HOLD #>
   etype                        ( )
;

\ Assume point and VT cursor are together,
\ type out rest of line,
\ and return VT cursor here.
\ Factor of ki.redraw.
: ki.heretype  ( -- )
   \ type out rest of text
   ki.a ki.> @ +                ( addr )
   ki.n @ ki.> @ -              ( addr n )
   TUCK                         ( n addr n )
   etype                        ( n )
   IF
      ki.curfix
   THEN
   \ clear rest of screen
   s" [J" etype
   ki.n @ ki.> @
   ki.motion
;

\ Assuming the VT cursor is at ki.>save,
\ redraw from whichever of ki.>save and ki.> is leftmost,
\ and reposition VT cursor at ki.> .
: ki.redraw
   ki.>save @ ki.> @            ( old new )
   > IF
      \ new point is behind old one
      ki.>save @ ki.> @         ( from to )
      ki.motion                 ( )
      ki.> @                    ( p )
   ELSE
      \ new point is forward of old one
      ki.>save @                ( p )
   THEN
   \ Position of current VT on stack;
   \ type out text to end.
   ki.n @                       ( p n )
   over -                       ( p u )
   ki.a                         ( p u a )
   rot +                        ( u addr )
   over                         ( u addr u )
   etype                        ( u )
   IF
      ki.curfix
   THEN
   s" [J" etype
   ki.n @ ki.> @
   ki.motion
;

: ki.edit
   0 tty.store
   0 tty.keypress

   BEGIN
      getc
      dup 0< IF
         \ negative: EOF or error
         drop 0                 ( 0 )
      ELSE
         \ save input byte
         ki.k !                 ( )
         \ save current point
         ki.> @ ki.>save !      ( )
         ki.fix                 ( addr u )
         findword               ( addr fl | 0 )
         0= IF
            ki.k 1 ki.insert
         ELSE
            DEPTH >r
            EXECUTE
            DEPTH r>            ( flag depth1 depth0 )
            - IF
               s" stack imbalance" etype
            THEN
         THEN
         ki.redraw
      THEN
      WHILE
   REPEAT

   0 tty.restore
;

: ki
   hl.new
   ki.fresh
   ki.edit
;

\ Key Input Prompt and Loop
: kipl
   BEGIN
      ki
      ki.input
      ?dup IF
         evaluate
         s"  ok" etype 10 eemit   0
      ELSE
         drop   1
      THEN
   UNTIL
;

: rc.defined true ;

\ 3 valued:
\ -1 always interactive
\ 0 not interactive
\ 1 interactive unless args provided
VARIABLE interactive
1 interactive !

' kipl *vreset !

: disable-interactive
   ['] sysexit *vreset !
;

: -c?  ( c-addr u -- flag )  s" -c" COMPARE 0= ;

\ Handle command line options
: options
   BEGIN
      false             \ false to break at while
      2 argc @ < IF
          1 arg -c? IF
             disable-interactive
             drop
             2 arg
             arg-pop arg-pop
             evaluate
             true       \ true to continue at while
          THEN
      THEN
      WHILE
   REPEAT
;
options

\ Adjust addr u pair to skip past an initial shebang line.
: shebang  ( addr u -- n-addr n-u )
   over c@              ( addr u c )
   [CHAR] # <> IF
      exit
   THEN
   ( addr u )
   dup dup >r           ( addr u u ) ( r: u )
   0 DO
      \ l is, or will be, the index of the earliest NL
      over              ( addr l addr )
      I + c@            ( addr l ch )
      10 = IF
         \ :todo: reimplement using `leave`
         I min
      THEN
   LOOP
   ( addr l )
   r> swap              ( addr u l )
   /STRING
;

\ If there is a command line argument,
\ run it as Forth.
: run-args
   1 argc @ < IF
      disable-interactive
      1 arg openr       ( fileid ior )
      abort" File not found
"
      fmapr             ( addr u )
      shebang
      evaluate
   THEN
;
run-args
