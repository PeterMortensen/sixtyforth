: ' parse-word findword dup 0= ?dup drop drop ;

: [compile] ' , ; immediate

: char parse-word drop c@ ;

: [char] char [compile] literal ; immediate

: ( [char] ) parse drop drop ; immediate

( --- We have now defined comments, so we can use them. --- )

( Here's the missing comments, from the above routines: )

( '             std1983 )
(   Weird definition of ' avoids using IF )
( [COMPILE]     std1983 )
( CHAR          std1994 )
( [CHAR]        std1994 )
( (             std1983 )

( COMPILE       std1983 )
( Using the definition in [FORTH1994] A.6.1.2033 )
: compile r> dup @ , cell+ >r ;

( IF            std1983 )
: if ( -- token    / at compile time )
  compile 0branch
  here          ( token )
  ( compile dummy offset )
  true ,
; immediate

( ELSE          std1983 )
: else ( token -- newtoken      / at compile time )
  compile branch
  here          ( token newtoken )
  ( compile dummy offset )
  true ,
  swap          ( newtoken token )
  here over -   ( newtoken token offset )
  swap          ( newtoken offset token )
  !             ( newtoken )
; immediate

( THEN          std1983 )
: then
  here over - swap ! ; immediate

( VARIABLE      std1983 )
: variable create 1 cells allot ;

( DNEGATE       std1983 )
: dnegate ( d1 -- -d1 )
  -1 1 m*/ ;

: 2drop drop drop ;

: .( [char] ) parse type ; immediate

( *fix-cfa )
( Fixes the CFA of the last defined word )
( to point to address following call to *fix-cfa )
( in the calling word; )
( and terminate excution of calling word. )
: *fix-cfa r> last name> ! ;

( DOES>         std1983 )
: does> compile *fix-cfa codedoes       ( addr n )
  here over allot                       ( from n to )
  swap cmove ; immediate

( fetch byte C from addr, )
( then compute C M AND X XOR )
( and store at addr. )
: c!xa ( X M addr -- )
  dup >r c@ and xor r> c! ;

variable chbuf

( Read single byte )
: fgetc ( fd -- c/-9999999/-ve )
  chbuf 1 sysread
  dup 0 < if
  else
    0= if -9999999
    else
      chbuf c@
    then
  then
;

( Read single byte from stdin )
: getc ( -- c )
       ( -- -9999999    / on End of File )
       ( -- -ve         / on os error )
  0 fgetc ;

create rltcgetsv 36 allot

( Store TTY settings. )
: tty.store ( fd -- )
  rltcgetsv tcgets drop
;

( Put TTY in keypress mode )
: tty.keypress ( fd -- )
  ( Fetch and modify TTY settings... )
  dup tcgetsv tcgets drop               ( fd )
  ( Clear ICANON and ECHO bits. )
  0 10 invert tcgetsv 12 + c!xa         ( fd )
  tcgetsv tcsets drop
;

( Restore TTY settings. )
: tty.restore ( fd -- )
  rltcgetsv tcsets drop
;

( Put the TTY into keypress mode to get a single keypress )
: getch

  0 tty.store
  0 tty.keypress

  getc

  0 tty.restore
;

( see note/fstat.md )
create fstatbuf 144 allot

: fstat* ( n -- res )
  ( leaves result in `fstatbuf` )
  fstatbuf 0 5 syscall3 ;

: flen ( n -- sz/err )
  ( Length of file opened on fildes n )
  ( -ve if there is an error )
  fstat* ?dup if else fstatbuf 48 + @ then ;


: fmapr ( n -- addr u )
  ( Map fildes n into memory for reading )
  ( address and length of mapping are left on stack )
  dup flen dup 1 < if drop drop 0 0 else
  ( n sz )
  swap over                     ( sz n sz )
  0 rot rot swap                ( sz 0 sz n )
  1 2 rot                       ( sz 0 sz 1 2 n )
  0 9 syscall6                  ( sz addr )
  swap then ;

: rc4 4 fmapr ?dup if evaluate else drop then ;

: rl.z 96 ;             ( size )
create rl.a rl.z allot  ( address )
variable rl.>           ( cursor )
variable rl.n           ( validity )
0 rl.> !
0 rl.n !
variable rl.k           ( small buffer for key input )
variable rl.fixk        ( small buffer used for findword )

: rl.input rl.a rl.n @ ;

: rl.insert ( addr u -- 1 )
  dup rl.n @ +
  rl.z >
  if
    ( buffer full )
    s" #%#" type
    0
  else
    ( addr u )
    ( copy text to right of cursor up to make room )
    rl.a rl.> @ +       ( addr u from )
    over                ( addr u from u )
    rl.> @ + rl.a +     ( addr u from to )
    rl.n @ rl.> @ -     ( addr u from to n )
    cmove>              ( addr u )
    ( increment length )
    dup rl.n +!         ( addr u )
    ( copy new input into cursor )
    rl.a rl.> @ +       ( addr u > )
    over                ( addr u > u )
    ( bump rl.> )
    rl.> +!             ( addr u > )
    swap cmove          ( )

    rl.input type
    1
  then
;

( fix-up the single character in rl.k )
( Convert Control Chars to ^J form )
: rl.fix
  rl.k c@
  32 <
  if
    [char] ^ rl.fixk c!
    rl.k c@
    64 or rl.fixk 1+ c!
    rl.fixk 2
  else
    rl.k c@ rl.fixk c!
    rl.fixk 1
  then
;

( Makes LF exit the RL loop )
: ^J 0 ;

: rl
  0 tty.store
  0 tty.keypress

  begin
    getc
    dup 0 <
    if
      drop 0                    ( negative: EOF or error )
    else
      rl.k !
      rl.fix over over type findword
      0= if rl.k 1 rl.insert else execute then
    then
    while
  repeat
  drop

  0 tty.restore
;

: rc.defined true ;
