: ' parse-word findword dup 0= ?dup drop drop ;

: [compile] ' , ; immediate

: char parse-word drop c@ ;

: [char] char [compile] literal ; immediate

: ( [char] ) parse drop drop ; immediate

( --- We have now defined comments, so we can use them. --- )

( Here's the missing comments, from the above routines: )

( '             std1983 )
(   Weird definition of ' avoids using IF )
( [COMPILE]     std1983 )
( CHAR          std1994 )
( [CHAR]        std1994 )
( (             std1983 )

( COMPILE       std1983 )
( Using the definition in [FORTH1994] A.6.1.2033 )
: compile r> dup @ , cell+ >r ;

( IF            std1983 )
: if ( -- token    / at compile time )
  compile 0branch
  here          ( token )
  ( compile dummy offset )
  true ,
; immediate

( ELSE          std1983 )
: else ( token -- newtoken      / at compile time )
  compile branch
  here          ( token newtoken )
  ( compile dummy offset )
  true ,
  swap          ( newtoken token )
  here over -   ( newtoken token offset )
  swap          ( newtoken offset token )
  !             ( newtoken )
; immediate

( THEN          std1983 )
: then
  here over - swap ! ; immediate

( VARIABLE      std1983 )
: variable create 1 cells allot ;

( DNEGATE       std1983 )
: dnegate ( d1 -- -d1 )
  -1 1 m*/ ;

: 2drop drop drop ;
: 2dup over over ;
: tuck ( a b -- b a b )
  swap over ;

: max over over < if swap then drop ;

: .( [char] ) parse type ; immediate

( *fix-cfa )
( Fixes the CFA of the last defined word )
( to point to address following call to *fix-cfa )
( in the calling word; )
( and terminate excution of calling word. )
: *fix-cfa r> last name> ! ;

( DOES>         std1983 )
: does> compile *fix-cfa codedoes       ( addr n )
  here over allot                       ( from n to )
  swap cmove ; immediate

( fetch byte C from addr, )
( then compute C M AND X XOR )
( and store at addr. )
: c!xa ( X M addr -- )
  dup >r c@ and xor r> c! ;

variable chbuf

( Read single byte )
: fgetc ( fd -- c/-9999999/-ve )
  chbuf 1 sysread
  dup 0 < if
  else
    0= if -9999999
    else
      chbuf c@
    then
  then
;

( Read single byte from stdin )
: getc ( -- c )
       ( -- -9999999    / on End of File )
       ( -- -ve         / on os error )
  0 fgetc ;

create tty.buffer 36 allot

( Store TTY settings. )
: tty.store ( fd -- )
  tty.buffer tcgets drop
;

( Put TTY in keypress mode )
: tty.keypress ( fd -- )
  ( Fetch and modify TTY settings... )
  dup tcgetsv tcgets drop               ( fd )
  ( Clear ICANON and ECHO bits. )
  0 10 invert tcgetsv 12 + c!xa         ( fd )
  tcgetsv tcsets drop
;

( Restore TTY settings. )
: tty.restore ( fd -- )
  tty.buffer tcsets drop
;

( Put the TTY into keypress mode to get a single keypress )
: getch

  0 tty.store
  0 tty.keypress

  getc

  0 tty.restore
;

( Key Input )

( type on stderr )
: etype ( addr u -- )
  2 ftype ;

: eemit ( ch -- )
  2 femit ;

: ki.z 96 ;             ( size )
create ki.a ki.z allot  ( address )
variable ki.>           ( point )
variable ki.n           ( validity )
variable ki.>save
variable ki.k           ( small buffer for key input )
variable ki.fixk        ( small buffer used for findword )

( reset key variables to create a fresh buffer )
: ki.fresh
  0 ki.> !
  0 ki.n !
  0 ki.>save !
;
ki.fresh

: ki.input ki.a ki.n @ ;

( Insert the text into the buffer at the current point, )
( and advance the point past the inserted text. )
: ki.insert ( addr u -- 1 )
  dup ki.n @ +
  ki.z >
  if
    ( buffer full )
    s" #%#" etype
    0
  else
    ( addr u )
    ( copy text to right of point up to make room )
    ki.a ki.> @ +       ( addr u from )
    over                ( addr u from u )
    ki.> @ + ki.a +     ( addr u from to )
    ki.n @ ki.> @ -     ( addr u from to n )
    cmove>              ( addr u )
    ( increment length )
    dup ki.n +!         ( addr u )
    ( copy new input at point )
    ki.a ki.> @ +       ( addr u > )
    over                ( addr u > u )
    ( bump ki.> )
    ki.> +!             ( addr u > )
    swap cmove          ( )

    1
  then
;

( fix-up the single character in ki.k )
( Convert Control Chars to ^J form,
( and prefix everything with k: )
: ki.fix
  s" k:" ki.fixk swap cmove
  ki.k c@
  32 <
  if
    [char] ^ ki.fixk 2 + c!
    ki.k c@
    64 or ki.fixk 3 + c!
    ki.fixk 4
  else
    ki.k c@ ki.fixk 2 + c!
    ki.fixk 3
  then
;

: erase-backward-char
  ki.> @
  if
    ( copy down characters )
    ki.a ki.> @ +               ( from )
    dup 1-                      ( from to )
    ki.n @ ki.> @ -             ( from to n )
    cmove
    ( shrink buffer )
    -1 ki.> +!
    -1 ki.n +!
  then
;

( Create a binding for the current stty erase key )
0 tty.store
tty.buffer 19 + c@
ki.k c!
ki.fix *create *stdexe here body> ! ] erase-backward-char 1 ; ( )

: end-of-line
  ki.n @ ki.> ! ;

( Makes LF exit the RL loop )
: k:^J
  end-of-line
  s"  " ki.insert drop
  0
;

( beginning-of-line )
: k:^A 0 ki.> ! 1 ;

( backward-char )
: k:^B ki.> @ 1- 0 max ki.> ! 1 ;

( erase-forward-char )
: k:^D
  ( if entire line is empty, terminate )
  ki.n @ 0= ki.> @ 0=
  and
  if
    0
    exit
  then
  ( test if there are any characters ahead of point to erase )
  ki.n @                        ( n )
  ki.> @                        ( n > )
  -                             ( u )
  if
    ( copy down characters )
    ki.a ki.> @ +               ( to )
    dup 1+ swap                 ( from to )
    ki.n @ ki.> @ - 1-          ( from to n )
    cmove
    ( shrink buffer )
    -1 ki.n +!
  then
  1
;

( end-of-line )
: k:^E
  end-of-line 1
;

( forward-char )
: k:^F ki.> @ 1 + ki.n @ min ki.> ! 1 ;

( kill-to-end )
: k:^K ki.> @ ki.n ! 1 ;

( Fix cursor position if it is at end of row )
: ki.curfix
  ki.n @
  s>d
  80
  um/mod                        ( col row )
  0> swap 0= and
  if
    10 eemit
  then
;

( Emit ANSI codes to move VT cursor,
( from location from to location to. )
( `from` and `to` are byte positions in the ki.a input string. )
: ki.motion ( from to -- )
  80 >r
  s>d r@ um/mod                 ( from to-col to-row )
  rot                           ( to-col to-row from )
  s>d r> um/mod                 ( to-col to-row from-col from-row )
  rot                           ( to-col from-col from-row to-row )
  ( vertical motion )
  2dup                          ( t-col f-col f-row t-row f-row t-row )
  > if
    ( upward motion )
    - s>d                       ( t-col f-col dn )
    <# [char] A hold #s [char] [ hold 27 hold #>
    etype                       ( t-col f-col )
  else
    2dup <                      ( t-col f-col f-row t-row flag )
    if
      ( downward motion )
      - negate s>d              ( t-col f-col dn )
      <# [char] B hold #s [char] [ hold 27 hold #>
      etype                     ( t-col f-col )
    else
      2drop
    then
  then
  drop                          ( t-col )
  1+ s>d <# [char] G hold #s [char] [ hold 27 hold #>
  etype                         ( )
;

( Assume point and VT cursor are together, )
( type out rest of line, )
( and return VT cursor here. )
( Factor of ki.redraw )
: ki.heretype ( -- )
  ( type out rest of text )
  ki.a ki.> @ +                 ( addr )
  ki.n @ ki.> @ -               ( addr n )
  tuck                          ( n addr n )
  etype                         ( n )
  if
    ki.curfix
  then
  ( clear rest of screen )
  s" [J" etype
  ki.n @ ki.> @
  ki.motion
;

( Assuming the VT cursor is at ki.>save, )
( redraw from whichever of ki.>save and ki.> is leftmost, )
( and reposition VT cursor at ki.> . )
: ki.redraw
  ki.>save @ ki.> @             ( old new )
  > if
    ( new point is behind old one )
    ki.>save @ ki.> @           ( from to )
    ki.motion                   ( )
    ki.> @                      ( p )
  else
    ( new point is forward of old one )
    ki.>save @                  ( p )
  then
  ( position of current VT on stack )
  ( type out text to end )
  ki.n @                        ( p n )
  over -                        ( p u )
  ki.a                          ( p u a )
  rot +                         ( u addr )
  over                          ( u addr u )
  etype                         ( u )
  if
    ki.curfix
  then
  s" [J" etype
  ki.n @ ki.> @
  ki.motion
;

: ki.edit
  0 tty.store
  0 tty.keypress

  begin
    getc
    dup 0 <                     ( ch flag )
    if
      ( negative: EOF or error )
      drop 0                    ( 0 )
    else
      ( save input byte )
      ki.k !                    ( )
      ( save current point )
      ki.> @ ki.>save !         ( )
      ki.fix                    ( addr u )
      findword                  ( addr fl | 0 )
      0= if
        ki.k 1 ki.insert
      else
        depth >r
        execute
        depth r>                ( flag depth1 depth0 )
        -
        if
          s" stack imbalance" etype
        then
      then
      ki.redraw
    then
    while
  repeat

  0 tty.restore
;

: ki
  ki.fresh
  ki.edit
;

( see note/fstat.md )
create fstatbuf 144 allot

: fstat* ( n -- res )
  ( leaves result in `fstatbuf` )
  fstatbuf 0 5 syscall3 ;

: flen ( n -- sz/err )
  ( Length of file opened on fildes n )
  ( -ve if there is an error )
  fstat* ?dup if else fstatbuf 48 + @ then ;


: fmapr ( n -- addr u )
  ( Map fildes n into memory for reading )
  ( address and length of mapping are left on stack )
  dup flen dup 1 < if drop drop 0 0 else
  ( n sz )
  swap over                     ( sz n sz )
  0 rot rot swap                ( sz 0 sz n )
  1 2 rot                       ( sz 0 sz 1 2 n )
  0 9 syscall6                  ( sz addr )
  swap then ;

: rc4 4 fmapr ?dup if evaluate else drop then ;

( Key Input Prompt and Loop )
: kipl
  begin
    ki
    ki.input
    ?dup
    if
      evaluate
      s"  ok" etype 10 eemit
      0
    else
      drop
      1
    then
  until
;

: rc.defined true ;

( Modify reset vector to point to kipl ... )
' kipl *vreset ! ( )
( ... and jump through vector to continue at kipl )
quit
