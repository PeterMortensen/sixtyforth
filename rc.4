: then
  here over - swap ! ; immediate

: ' parse-word findword if exit then 0 ;

: [compile] ' , ; immediate

: [char] char [compile] literal ; immediate

: ( [char] ) parse drop drop ; immediate

( NOTE: until ( is defined, above, we can't have comments. )

( Here's the missing comments: )

( THEN          std1983 )
( '             std1983 )
( [COMPILE]     std1983 )
( [CHAR]        std1994 )
( (             std1983 )

( VARIABLE      std1983 )
: variable create 1 cells allot ;

( DNEGATE       std1983 )
: dnegate ( d1 -- -d1 )
  -1 1 m*/ ;

: 2drop drop drop ;

: .( [char] ) parse type ; immediate

( COMPILE       std1983 )
( Using the definition in [FORTH1994] A.6.1.2033 )
: compile r> dup @ , cell+ >r ;

( *fix-cfa )
( Fixes the CFA of the last defined word )
( to point to address following call to *fix-cfa )
( in the calling word; )
( and terminate excution of calling word. )
: *fix-cfa r> last name> ! ;

( DOES>         std1983 )
: does> compile *fix-cfa codedoes       ( addr n )
  here over allot                       ( from n to )
  swap cmove ; immediate

( fetch byte C from addr, )
( then compute C M AND X XOR )
( and store at addr. )
: c!xa ( X M addr -- )
  dup >r c@ and xor r> c! ;

variable chbuf

create rltcgetsv 36 allot

( Read single byte )
: getc
  0 chbuf 1 sysread drop
  chbuf c@ ;

: getch

  ( Store original TTY settings. )
  0 rltcgetsv tcgets drop
  ( Fetch and modify TTY settings... )
  0 tcgetsv tcgets drop
  ( Clear ICANON and ECHO bits. )
  0 10 invert tcgetsv 12 + c!xa
  0 tcgetsv tcsets drop

  ( read )
  getc

  ( Restore TTY settings. )
  0 rltcgetsv tcsets drop
;

( see note/fstat.md )
create fstatbuf 144 allot

: fstat* ( n -- res )
  ( leaves result in `fstatbuf` )
  fstatbuf 0 5 syscall3 ;

: flen ( n -- sz/err )
  ( Length of file opened on fildes n )
  ( -ve if there is an error )
  fstat* ?dup if else fstatbuf 48 + @ then ;


: fmapr ( n -- addr u )
  ( Map fildes n into memory for reading )
  ( address and length of mapping are left on stack )
  dup flen dup 1 < if drop drop 0 0 else
  ( n sz )
  swap over                     ( sz n sz )
  0 rot rot swap                ( sz 0 sz n )
  1 2 rot                       ( sz 0 sz 1 2 n )
  0 9 syscall6                  ( sz addr )
  swap then ;

: rc4 4 fmapr ?dup if evaluate else drop then ;

: rc.defined true ;
