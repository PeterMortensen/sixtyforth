: 2drop   drop drop ;
: \   10 parse 2drop ; immediate         \ Now we have comments

\ std1983
: '
   \ Avoid using IF, which is not defined yet
   parse-word findword dup 0= ?dup 2drop ;
\ std1983
: [compile]   ' , ; immediate
\ std1994
: char   parse-word drop c@ ;
\ std1994
: [char]   char [compile] literal ; immediate
\ std1983
: (   [char] ) parse 2drop ; immediate

( Now we have round bracket comments )

\ Using the definition in [FORTH1994] A.6.1.2033
: compile   r> dup @ , cell+ >r ;

\ std1983
: [']   ' [compile] literal ; immediate

: 2dup  ( x x' -- x x' x x' )  over over ;
: tuck  ( a b -- b a b )  swap over ;
\ std1983
: .(  [char] ) parse type ; immediate
\ std1994
: s>d  ( n -- d )  dup 0< ;

\ std1994 core-ext
: 2r>   ( R: x1 x2 -- ) ( -- x1 x2 )
   r> r> r>     ( ret x2 x1 )
   rot >r       ( x2 x1 )
   swap         ( x1 x2 )
;

\ std1994
: 2*  ( x -- x' )  2 * ;

\ std1983
: variable    create 1 cells allot ;

\ std1994
: mod  ( n1 n2 -- n3 )
   \ Implementation as per [std1994]
   >r s>d r> sm/rem drop
;

\ std1994
: 2!  ( x1 x2 addr -- )  tuck !   cell+ ! ;

\ std1994
: 2@  ( addr -- x1 x2 )
   dup cell+ @   swap @ ;

\ std1994 double
: d0=  ( xd -- flag )  or 0= ;

\ std1994
: count  ( addr -- addr' ch )  dup 1+ swap c@ ;

\ std1994 string
: /string  ( addr u n -- addr' u' )
   tuck -               ( addr n u' )
   >r + r>              ( addr' u' )
;

\ ## Control Flow

create begin-token

\ std1983
: begin  ( -- token begin-token / at compile time )
   here begin-token
; immediate

\ std1983
: until  ( token begin-token -- / at compile time )
   \ todo: check token
   drop
   compile 0branch
   here         ( token here )
   -            ( byte-offset )
   ,
; immediate

create while-token

\ std1983
: while  ( token begin-token -- w-token while-token )
   compile 0branch
   \ todo: check token
   here         ( token begin-token w-token )
   while-token  ( token begin-token w-token while-token )
   true ,
; immediate

\ std1994
: repeat  ( b-token 'BEGIN w-token 'WHILE -- )
   2swap        ( w-token 'WHILE b-token 'BEGIN )
   drop         \ :todo: safety check 'BEGIN
   compile branch
   here -       ( w-token 'WHILE offset )
   ,            ( w-token 'WHILE )
   drop         ( w-token )
   here         ( w-token here )
   over         ( w-token here w-token )
   -            ( w-token offset )
   swap !
; immediate

\ std1983
: if  ( -- token    / at compile time )
   compile 0branch
   here         ( token )
   \ compile dummy offset
   true ,
; immediate

\ std1983
: else  ( token -- newtoken      / at compile time )
   compile branch
   here         ( token newtoken )
   ( compile dummy offset )
   true ,
   swap         ( newtoken token )
   here over -  ( newtoken token offset )
   swap         ( newtoken offset token )
   !            ( newtoken )
; immediate

\ std1983
: then
   here over - swap ! ; immediate

\ std1983
: do  ( limit base --    / C: -- token )
   compile 2>r
   here         ( token )
; immediate

\ Implements the test part of a DO LOOP,
\ leaving a flag on the stack.
: looptest  ( -- flag    / R: limit index -- limit index' )
   r>           ( ret )
   2r@          ( ret limit index )
   1+           ( ret limit index' )
   r> drop      ( r: limit )
   dup >r       ( r: limit index' )
   =            ( ret flag )
   swap >r      ( flag )
;

\ std1983
: loop  ( R: limit base -- limit base+1 |        / C: do-token -- )
   compile looptest
   compile 0branch
   here         ( do-token here )
   -            ( byte-offset )
   ,
   compile 2r> compile 2drop
; immediate

\ std1983
: i  ( -- index )
   2r@ drop
;

\ ##

\ std1983
: max   2dup < if swap then drop ;

\ Fixes the CFA of the last defined word
\ to point to address following call to *fix-cfa
\ in the calling word;
\ and terminate excution of calling word.
: *fix-cfa   r> last name> ! ;

\ std1983
: does>   compile *fix-cfa codedoes     ( addr n )
   here over allot                      ( from n to )
   swap cmove ; immediate

\ std1983
: constant  ( x -- / -- x )
   variable last name> >body ! does> @ ;

\ std1994
: value   constant ;

\ std1994
: to  ( x -- )
   state @  abort" Not implemented in compiler"  ' >body ! ;

\ Map Anonymous
\ Request freshly allocated memory.
: map-anon  ( sz -- addr ior )
   0 swap               ( 0 sz )
   3 34                 ( 0 sz prot flags )
   -1 0                 ( 0 sz prot flags fd offset )
   9 syscall6           ( res )
   -4096 over u<        ( res flag )
   over and             ( addr ior )
;

\ ## Number Printing

300 constant pic-size
pic-size map-anon drop pic-size +
value picend
variable pic

\ double to double division
\ used in printing numbers
: uml/mod  ( ud u -- u-rem ud-quot )
   >r r@
   0 swap um/mod        ( L Mrem Mquot )
   r> swap >r           ( L Mrem u )
   um/mod               ( Lrem Lquot )
   r>                   ( Lrem ud-quot )
;

\ std1994
: hold  ( ch -- )
   pic @        ( ch addr )
   1-           ( ch addr' )
   tuck         ( addr' ch addr' )
   c!           ( addr' )
   pic !
;

\ std1994
: <#  ( -- )
   picend
   pic !
;

\ std1994
: #  ( ud -- ud' )
   base @
   uml/mod      ( r ud )
   rot          ( ud r )
   digit hold   ( ud )
;

\ std1994
: #s  ( ud -- 0. )
   begin
      #
      2dup      ( ud ud )
      d0=       ( ud flag )
   until
;

\ std1994
: sign  ( n -- )
   0< if
      [char] -
      hold
   then
;

\ std1994
: #>  ( ud -- addr u )
   2drop
   pic @
   picend       ( addr end )
   over -       ( addr u )
;

\ std1983
: u.  ( u -- )
   0
   <# bl hold #s #>
   type
;

\ Using <#, type out double with sign of n.
: .sign  ( n du -- )
   <#
      bl hold
      #s
      rot sign
   #>
   type
;

\ std1983
: .  ( n -- )
   dup abs 0    ( n du )        \ du same magnitude as n
   .sign ;

\ std1994 double
: d.  ( d -- )
   tuck dabs    ( n du )        \ n same sign as d
   .sign ;

\ ## String

\ 3-way comparison
\ result is -1 when u1 < u2
\           +1 when u2 < u1
\            0 when u1 = u2
: cmp  ( u1 u2 -- -1|0|1 )
   2dup u<      ( u1 u2 flag< )
   swap rot     ( flag< u2 u1 )
   u<           ( flag< flag> )
   -
;

\ std1994
: compare  ( c-addr1 u1 c-addr2 u2 -- n )
   rot 2dup 2>r
   min          ( c-addr1 c-addr2 n )
   false
   begin
      drop
      dup 0= if
        \ identical up to common part
        drop 2drop
        r> r> cmp
        exit
      then
      ( c-addr1 c-addr2 n )
      1-
      rot count >r      ( c-addr2 n c-addr1' )  ( r: ch1 )
      rot count >r      ( n c-addr1' c-addr2' )  ( r: ch1 ch2 )
      rot 2r>           ( c-addr1' c-addr2' n ch1 ch2 )
      cmp               ( c-addr1' c-addr2' n -1|0|1 )
      dup
  until
  2r> 2drop
  nip nip nip
;

\ ##

\ Convert from C string, by pushing its length.
: c>  ( addr -- addr u )
   -1           ( addr i )
   begin
      1+        ( addr i )
      2dup +    ( addr i p )
      c@        ( addr i ch )
      0=        ( addr i flag )
   until
;

\ ARGC and ARG modelled after gforth implementation.
\ The initial RSP register is the address of ARGC
\ (in the Linux ABI).
rsp constant argc
: arg  ( i -- i-addr i-len )
   1+ cells
   \ Following ARGC are the pointers to C strings.
   argc
   + @          ( addr )
   dup if
      c>        ( addr u )
   else
      0         ( 0 0 )
   then
;
: arg-pop  ( -- )
   argc @ 2 < if  exit  then
   argc 2 cells +       ( addr-from )
   argc cell+           ( addr-from addr-to )
   -1 argc +!
   argc @ cells         ( addr-from addr-to u )
   cmove
;

\ see note/fstat.md
create fstatbuf 144 allot

\ Modelled after ANSI `file-status`.
: file*status  ( n -- addr ior )
   \ Leaves result in `fstatbuf` which is left on stack.
   fstatbuf tuck 0 5 syscall3 ;

\ std1994 file
: file-size  ( fileid -- ud ior )
   file*status
   ?dup if
      0 swap                    ( x 0 ior )
   else
      48 + @  0                 ( ud )
      0                         ( ud 0 )
   then
;

\ File Map for Reading
\ Map fildes fd into memory for reading.
\ Address and length of mapping are left on stack.
: fmapr ( fd -- addr u )
   dup file-size                        ( fd ud ior )
   abort" File cannot be mapped"        ( fd ud )
   d>s                                  ( fd u )
   dup 1 < if
      drop drop
      0 0
   else
      ( n sz )
      tuck                              ( sz n sz )
      0 rot rot swap                    ( sz 0 sz n )
      \ For #defines, see /usr/include/asm-generic/mman-common.h
      \ PROT_READ 1
      \ PROT_WRITE 2
      \ MAP_PRIVATE 2
      \ MAP_ANONYMOUS 32
      1 2 rot                           ( sz 0 sz 1 2 n )
      0                                 ( sz 0 sz 1 2 n 0 )
      9 syscall6                        ( sz addr )
      swap
   then
;

4096 map-anon drop
constant openbuf        ( buffer for open pathname )

\ std1994
: r/o
   \ Modelled after the `flags` argument to open()
   \ See /usr/include/asm-generic/fcntl.h defines O_RDONLY
   0 ;

\ std1994 file
: open-file  ( c-addr u fam -- fileid ior )
   >r >r                ( c-addr )      ( r: fam u )
   openbuf r@           ( c-addr path u )
   cmove                ( )
   0 r>                 ( 0 u )         ( r: fam )
   openbuf 1+ +         ( 0 p )
   !
   openbuf              ( openbuf )
   r> 0                 ( openbuf fam 0 )
   \ For syscall numbers, see
   \ http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
   2 syscall3           ( fileid )
   dup 0 min            ( fileid 0 | ior ior )
;

\ Open file for reading.
: openr  ( c-addr u -- fileid ior )
   r/o open-file ;

\ ##

\ Fetch byte C from addr,
\ then compute C M AND X XOR
\ and store at addr.
: c!xa  ( X M addr -- )
   dup >r c@ and xor r> c! ;

variable chbuf

\ Read single byte.
: fgetc ( fd -- c/-9999999/-ve )
   chbuf 1 sysread
   dup 0< if
   else
      0= if -9999999
      else
         chbuf c@
      then
   then
;

\ Read single byte from stdin
: getc ( -- c )
       ( -- -9999999    / on End of File )
       ( -- -ve         / on os error )
   0 fgetc ;

\ Fetch and print 8 hex digits.
: @.8  ( addr -- )
   @ 4294967295 ( 2**32 - 1 ) and       ( w )
   base @ >r
   16 base !
   0                    ( ud )
   <# bl hold
      # # # # # # # #
   #>
   type
   r> base !
;



\ Get TTY settings, from TCGETS ioctl, and dump to stdout.
: tcgets.  ( fd -- res )
   here dup tcgets       ( here res )
   over @.8
   over 4 + @.8
   over 8 + @.8
   over 12 + @.8
   cr
   over 16 +
   20 dump              ( res )
   nip
;

create tty.buffer 36 allot

\ Store TTY settings.
: tty.store ( fd -- )
   tty.buffer tcgets drop
;

\ Put TTY in keypress mode.
: tty.keypress ( fd -- )
   \ Fetch and modify TTY settings...
   dup here tcgets drop                 ( fd )
   \ Clear ICANON and ECHO bits.
   0  10 invert  here 12 +  c!xa        ( fd )
   here tcsets drop
;

\ Restore TTY settings.
: tty.restore  ( fd -- )
   tty.buffer tcsets drop
;

create tty.szbuf 8 allot

: tiocgwinsz  ( fd p -- res )
   \ 0x5413, TIOCGWINSZ according to /usr/include/asm-generic/ioctls.h
   21523                ( fd p 0x5413 )
   swap                 ( fd 0x5413 p )
   ( ioctl )
   16 syscall3          ( res )
;

variable tty.vbuf
-1 tty.vbuf !

\ Number of columns in TTY.
: tty.cols ( -- cols )
   0 tty.szbuf
   tiocgwinsz
   0= if
      tty.szbuf 2+      ( a+2 )
      dup 1+            ( a+2 a+3 )
      c@ swap c@        ( b1 b0 )
      swap              ( b0 b1 )
      256 * +           ( cols )
      tty.vbuf !
   then
   tty.vbuf @
;

\ Put the TTY into keypress mode to get a single keypress.
: getch
   0 tty.store
   0 tty.keypress
   getc
   0 tty.restore
;

\ ## Key Input

\ type on stderr.
: etype  ( addr u -- )  2 ftype ;
\ emit on stderr.
: eemit  ( ch -- )  2 femit ;

\ size
: ki.z  96 ;
\ address
create ki.a ki.z allot
\ point
variable ki.>
\ validity
variable ki.n
variable ki.>save
\ small buffer for key input
variable ki.k
\ small buffer used for findword
variable ki.fixk

\ Reset key variables to create a fresh buffer
: ki.fresh
   0 ki.> !   0 ki.n !   0 ki.>save ! ;
ki.fresh

: ki.input  ( -- addr u )  ki.a ki.n @ ;

\ ## Historic Lines

\ Memory block for all strings in history.
variable hl.block
1000000000 map-anon drop hl.block !
\ history-pointer
variable hl.p
hl.block @ hl.p !

: hl.n   999 ;
create hl.array hl.n 2* cells allot

variable hl.next   0 hl.next !
variable hl.cursor   0 hl.cursor !

\ Index of earliest history element.
: hl.base  ( -- base )
   hl.n hl.next @ max
   hl.n -
;

: hl.curprev  ( -- flag )
   hl.cursor @  hl.base  >  if
      -1 hl.cursor +!
      true
   else
      0
   then
;

: hl.curnext  ( -- flag )
   hl.cursor @  hl.next @ 1-    ( c end )
   < if
      1 hl.cursor +!
      true
   else
      0
   then
;

\ Return address of uth double-world entry in hl.array.
: hl.a&  ( u -- addr )
   2* cells     ( byte-offset )
   hl.array     ( byte-offset hl.array )
   +            ( array-address )
;

\ Store addr u into the ith double-world entry in hl.array.
: hl.a!  ( u addr i -- )
   hl.a&        ( u addr array-addr )
   2!           ( )
;

\ Replace i with the address of the double word
\ for history element i;
\ 0 if invalid index.
: hl&  ( i -- addr )
   dup                  ( i i )
   hl.base              ( i i base )
   hl.next @            ( i i base limit )
   within  if
      hl.n mod          ( array-index )
      hl.a&             ( addr )
   else
      drop
      0
   then
;

\ Fetch string from history; 0 0 if invalid index.
: hl@  ( i -- addr u )
   hl&                  ( addr )
   dup if
      2@                ( u a )
      swap              ( a u )
   else
      drop
      0 0
   then
;

\ Save the string into most recent element of history;
\ modifying it.
: hl.save  ( from u -- )
   hl.next @ 1-         ( from u i )
   hl&                  ( from u h-addr )
   dup 0= if
      abort" hl.save problem"
   then
   \ :todo: check lengths here
   2dup                 ( from u h-addr u h-addr )
   cell+ !              ( from u h-addr )
   @                    ( from u to )
   \ calculate a new value for hl.p
   2dup                 ( from u to u to )
   +                    ( from u to new-p )
   hl.p !               ( from u to )
   swap cmove
;

\ Create a new history entry.
: hl.new  ( -- )
   0 hl.p @             ( 0 p )
   hl.next @            ( 0 p i )
   \ increment hl.next
   1 hl.next +!         ( 0 p i )
   \ set cursor
   dup hl.cursor !      ( 0 p i )
   hl&                  ( 0 p addr )
   2!
;

: hl.
   hl.base              ( i )
   begin
      dup hl.next @     ( i i n )
      <                 ( i flag )
   while
      dup .
      dup hl@           ( i addr u )
      type cr           ( i )
      1+                ( i+1 )
   repeat
   drop
;

\ hl.cursor     - which history element we are currently showing.
\ hl.next       - number of next history element to be created.
\ hl.next only ever increments.
\ The counterpart, hl.earliest, the earliest history element,
\ is not explicitly stored. It is computed by hl.base.

\ ^P and ^N move the history cursor up and down,
\ and as long as there is a history element in memory,
\ it is copied to the ki buffer.

\ History is a copy on write affair.

\ Modifying the ki buffer marks it as modified,
\ ^J saves the ki buffer to history, and marks it as frozen.
\ ^N, or ^P saves the ki buffer to history only if
\ the ki buffer is modified.

\ The most recent history element has associated with it,
\ a "frozen" flag, which is unset until enter is pressed.
\ It is used to control saving.
\ When the ki buffer is saved to history,
\ if the most recent history element is frozen,
\ a new history element is created;
\ otherwise, the most recent history element is used, then
\ marked as frozen.

\ The history list is only ever appended to.
\ Only the oldest history element can be removed,
\ and it is removed to make room for new ones.

\ The following behaviours are observed:
\ ^P and ^N scroll through history.
\ Executing a line creates a new history element.
\ Modifying a line creates a new history element,
\ but one which can be subsequently re-edited without creating
\ further new history elements.
\ ^P ... edits ... ^P ... edits ... will lose the first set of edits.


\ ## Key Input Commands

\ Insert the text into the buffer at the current point,
\ and advance the point past the inserted text.
: ki.insert  ( addr u -- 1 )
   dup ki.n @ +  ki.z  >  if
      \ buffer full
      s" #%#" etype
      0
   else
      ( addr u )
      \ copy text to right of point up to make room
      ki.a ki.> @ +     ( addr u from )
      over              ( addr u from u )
      ki.> @ + ki.a +   ( addr u from to )
      ki.n @ ki.> @ -   ( addr u from to n )
      cmove>            ( addr u )
      \ increment length
      dup ki.n +!       ( addr u )
      \ copy new input at point
      ki.a ki.> @ +     ( addr u > )
      over              ( addr u > u )
      \ bump ki.>
      ki.> +!           ( addr u > )
      swap cmove        ( )
      1
   then
;

\ fix-up the single character in ki.k
\ Convert Control Chars to ^J form,
\ and prefix everything with k:
: ki.fix
   s" k:" ki.fixk swap cmove
   ki.k c@  32  <  if
      [char] ^ ki.fixk 2 + c!
      ki.k c@
      64 or ki.fixk 3 + c!
      ki.fixk 4
   else
      ki.k c@ ki.fixk 2 + c!
      ki.fixk 3
   then
;

: erase-backward-char
   ki.> @  if
      \ copy down characters
      ki.a ki.> @ +     ( from )
      dup 1-            ( from to )
      ki.n @ ki.> @ -   ( from to n )
      cmove
      \ shrink buffer
      -1 ki.> +!
      -1 ki.n +!
   then
;

\ Create a binding for the current stty erase key
0 tty.store
tty.buffer 19 + c@
ki.k c!
ki.fix *create *stdexe here body> ! ] erase-backward-char 1 ; ( )

: end-of-line
   ki.n @ ki.> ! ;

\ Makes LF exit the KI loop
: k:^J
   end-of-line
   ki.input hl.save
   s"  " ki.insert drop
   0
;

\ beginning-of-line
: k:^A   0 ki.> !   1 ;

\ backward-char
: k:^B   ki.> @ 1-  0  max  ki.> !   1 ;

\ erase-forward-char
: k:^D
   \ if entire line is empty, terminate
   ki.n @ 0=  ki.> @ 0=  and  if
      0  exit
   then
   \ Test if there are any characters ahead of point to erase.
   ki.n @  ki.> @  -  if
      \ copy down characters
      ki.a ki.> @ +             ( to )
      dup 1+ swap               ( from to )
      ki.n @ ki.> @ - 1-        ( from to n )
      cmove
      \ shrink buffer
      -1 ki.n +!
   then
   1
;

\ end-of-line
: k:^E
   end-of-line   1
;

\ forward-char
: k:^F   ki.> @ 1+  ki.n @  min  ki.> !   1 ;

\ kill-to-end
: k:^K   ki.> @ ki.n !   1 ;

\ Move the current historic line into key input.
: hl.move
   hl.cursor @ hl@              ( from u )
   tuck ki.a swap               ( u from to u )
   cmove                        ( u )
   ki.n !  0 ki.> !
;

\ next
: k:^N
   hl.curnext if
      hl.move
   then
   1
;

\ previous
: k:^P
   hl.curprev if
      hl.move
   then
   1
;

\ Fix cursor position if it is at end of row
: ki.curfix
   ki.n @ s>d  tty.cols  um/mod ( col row )
   0>  swap 0=  and  if
      10 eemit
   then
;

\ Like #s, but always in decimal.
: #d
   base @ >r  10 base !
   #s
   r> base !
;

\ Emit ANSI codes to move VT cursor,
\ from location `from` to location `to`.
\ `from` and `to` are byte positions in the ki.a input string.
: ki.motion  ( from to -- )
   tty.cols >r
   s>d r@ um/mod                ( from to-col to-row )
   rot                          ( to-col to-row from )
   s>d r> um/mod                ( to-col to-row from-col from-row )
   rot                          ( to-col from-col from-row to-row )
   \ vertical motion
   2dup > if
      \ upward motion
      - s>d                     ( t-col f-col dn )
      <# [char] A hold #d [char] [ hold 27 hold #>
      etype                     ( t-col f-col )
   else
      2dup < if
         \ downward motion
         - negate s>d           ( t-col f-col dn )
         <# [char] B hold #d [char] [ hold 27 hold #>
         etype                  ( t-col f-col )
      else
         2drop
      then
   then
   drop                         ( t-col )
   1+ s>d <# [char] G hold #d [char] [ hold 27 hold #>
   etype                        ( )
;

\ Assume point and VT cursor are together,
\ type out rest of line,
\ and return VT cursor here.
\ Factor of ki.redraw.
: ki.heretype  ( -- )
   \ type out rest of text
   ki.a ki.> @ +                ( addr )
   ki.n @ ki.> @ -              ( addr n )
   tuck                         ( n addr n )
   etype                        ( n )
   if
      ki.curfix
   then
   \ clear rest of screen
   s" [J" etype
   ki.n @ ki.> @
   ki.motion
;

\ Assuming the VT cursor is at ki.>save,
\ redraw from whichever of ki.>save and ki.> is leftmost,
\ and reposition VT cursor at ki.> .
: ki.redraw
   ki.>save @ ki.> @            ( old new )
   > if
      \ new point is behind old one
      ki.>save @ ki.> @         ( from to )
      ki.motion                 ( )
      ki.> @                    ( p )
   else
      \ new point is forward of old one
      ki.>save @                ( p )
   then
   \ Position of current VT on stack;
   \ type out text to end.
   ki.n @                       ( p n )
   over -                       ( p u )
   ki.a                         ( p u a )
   rot +                        ( u addr )
   over                         ( u addr u )
   etype                        ( u )
   if
      ki.curfix
   then
   s" [J" etype
   ki.n @ ki.> @
   ki.motion
;

: ki.edit
   0 tty.store
   0 tty.keypress

   begin
      getc
      dup 0< if
         \ negative: EOF or error
         drop 0                 ( 0 )
      else
         \ save input byte
         ki.k !                 ( )
         \ save current point
         ki.> @ ki.>save !      ( )
         ki.fix                 ( addr u )
         findword               ( addr fl | 0 )
         0= if
            ki.k 1 ki.insert
         else
            depth >r
            execute
            depth r>            ( flag depth1 depth0 )
            - if
               s" stack imbalance" etype
            then
         then
         ki.redraw
      then
      while
   repeat

   0 tty.restore
;

: ki
   hl.new
   ki.fresh
   ki.edit
;

\ Key Input Prompt and Loop
: kipl
   begin
      ki
      ki.input
      ?dup if
         evaluate
         s"  ok" etype 10 eemit   0
      else
         drop   1
      then
   until
;

: rc.defined true ;

\ 3 valued:
\ -1 always interactive
\ 0 not interactive
\ 1 interactive unless args provided
variable interactive
1 interactive !

' kipl *vreset !

: disable-interactive
   ['] sysexit *vreset !
;

: -c?  ( c-addr u -- flag )  s" -c" compare 0= ;

\ Handle command line options
: options
   begin
      false             \ false to break at while
      2 argc @ < if
          1 arg -c? if
             disable-interactive
             drop
             2 arg
             arg-pop arg-pop
             evaluate
             true       \ true to continue at while
          then
      then
      while
   repeat
;
options

\ Adjust addr u pair to skip past an initial shebang line.
: shebang  ( addr u -- n-addr n-u )
   over c@              ( addr u c )
   [char] # <> if
      exit
   then
   ( addr u )
   dup dup >r           ( addr u u ) ( r: u )
   0 do
      \ l is, or will be, the index of the earliest NL
      over              ( addr l addr )
      i + c@            ( addr l ch )
      10 = if
         \ :todo: reimplement using `leave`
         i min
      then
   loop
   ( addr l )
   r> swap              ( addr u l )
   /string
;

\ If there is a command line argument,
\ run it as Forth.
: run-args
   1 argc @ < if
      disable-interactive
      1 arg openr       ( fileid ior )
      abort" File not found
"
      fmapr             ( addr u )
      shebang
      evaluate
   then
;
run-args
