: ' parse-word findword dup 0= ?dup drop drop ;

: [compile] ' , ; immediate

: char parse-word drop c@ ;

: [char] char [compile] literal ; immediate

: ( [char] ) parse drop drop ; immediate

( --- We have now defined comments, so we can use them. --- )

( Here's the missing comments, from the above routines: )

( '             std1983 )
(   Weird definition of ' avoids using IF )
( [COMPILE]     std1983 )
( CHAR          std1994 )
( [CHAR]        std1994 )
( (             std1983 )

( COMPILE       std1983 )
( Using the definition in [FORTH1994] A.6.1.2033 )
: compile r> dup @ , cell+ >r ;

( IF            std1983 )
: if ( -- token    / at compile time )
  compile 0branch
  here          ( token )
  ( compile dummy offset )
  true ,
; immediate

( ELSE          std1983 )
: else ( token -- newtoken      / at compile time )
  compile branch
  here          ( token newtoken )
  ( compile dummy offset )
  true ,
  swap          ( newtoken token )
  here over -   ( newtoken token offset )
  swap          ( newtoken offset token )
  !             ( newtoken )
; immediate

( THEN          std1983 )
: then
  here over - swap ! ; immediate

( VARIABLE      std1983 )
: variable create 1 cells allot ;

( DNEGATE       std1983 )
: dnegate ( d1 -- -d1 )
  -1 1 m*/ ;

: 2drop drop drop ;

: .( [char] ) parse type ; immediate

( *fix-cfa )
( Fixes the CFA of the last defined word )
( to point to address following call to *fix-cfa )
( in the calling word; )
( and terminate excution of calling word. )
: *fix-cfa r> last name> ! ;

( DOES>         std1983 )
: does> compile *fix-cfa codedoes       ( addr n )
  here over allot                       ( from n to )
  swap cmove ; immediate

( fetch byte C from addr, )
( then compute C M AND X XOR )
( and store at addr. )
: c!xa ( X M addr -- )
  dup >r c@ and xor r> c! ;

variable chbuf

( Read single byte )
: fgetc ( fd -- c/-9999999/-ve )
  chbuf 1 sysread
  dup 0 < if
  else
    0= if -9999999
    else
      chbuf c@
    then
  then
;

( Read single byte from stdin )
: getc ( -- c )
       ( -- -9999999    / on End of File )
       ( -- -ve         / on os error )
  0 fgetc ;

create rltcgetsv 36 allot

( Store TTY settings. )
: tty.store ( fd -- )
  rltcgetsv tcgets drop
;

( Put TTY in keypress mode )
: tty.keypress ( fd -- )
  ( Fetch and modify TTY settings... )
  dup tcgetsv tcgets drop               ( fd )
  ( Clear ICANON and ECHO bits. )
  dup 10 invert tcgetsv 12 + c!xa       ( fd )
  tcgetsv tcsets drop
;

( Restore TTY settings. )
: tty.restore ( fd -- )
  rltcgetsv tcsets drop
;

( Put the TTY into keypress mode to get a single keypress )
: getch

  0 tty.store
  0 tty.keypress

  getc

  0 tty.restore
;

( see note/fstat.md )
create fstatbuf 144 allot

: fstat* ( n -- res )
  ( leaves result in `fstatbuf` )
  fstatbuf 0 5 syscall3 ;

: flen ( n -- sz/err )
  ( Length of file opened on fildes n )
  ( -ve if there is an error )
  fstat* ?dup if else fstatbuf 48 + @ then ;


: fmapr ( n -- addr u )
  ( Map fildes n into memory for reading )
  ( address and length of mapping are left on stack )
  dup flen dup 1 < if drop drop 0 0 else
  ( n sz )
  swap over                     ( sz n sz )
  0 rot rot swap                ( sz 0 sz n )
  1 2 rot                       ( sz 0 sz 1 2 n )
  0 9 syscall6                  ( sz addr )
  swap then ;

: rc4 4 fmapr ?dup if evaluate else drop then ;

: rc.defined true ;
